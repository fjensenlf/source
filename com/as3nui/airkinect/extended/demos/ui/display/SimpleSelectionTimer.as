/* * Copyright (c) 2012 AS3NUI * * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is furnished to * do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all copies * or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. */package com.as3nui.airkinect.extended.demos.ui.display {	import com.as3nui.nativeExtensions.air.kinect.extended.ui.display.BaseTimerSprite;	 import flash.display.Sprite;	 import flash.geom.Point;   // import flash.events.MouseEvent;    //import flash.events.Event	public class SimpleSelectionTimer extends BaseTimerSprite {		private var _size:Number = 25;		//private var _color:uint;				var my_canvas:Sprite = new Sprite();		var my_canvas2:Sprite = new Sprite();        var deg_to_rad=0.0174532925;        var charging:Boolean=false;        var power:int=0;				public function SimpleSelectionTimer() { //color:uint = 0xff0000			addChild(my_canvas);			addChild(my_canvas2);						//_color = color;			draw();		}		private function draw():void {			/*this.graphics.clear();			this.graphics.lineStyle(1);			this.graphics.beginFill(0xfff600, .4);			this.graphics.drawRect(-_size/2,-_size/2,_size, _size);			this.graphics.lineStyle(0);			this.graphics.beginFill(_color, 1);			this.graphics.drawRect(-_size/2,_size/2, _size, -(_progress * _size));			trace(_progress * _size, _progress , _size,power);*/			var p:Point = new Point(0, 0);			var circle:Sprite = new Sprite();			circle.graphics.beginFill(0xffffff,0.2);			circle.graphics.drawCircle(p.x, p.y, 28);			circle.graphics.drawCircle(p.x, p.y, 22);			circle.alpha = 0.5;			addChild(circle);									if (_progress == 0) {					charging=false;            		my_canvas.graphics.clear();					my_canvas2.graphics.clear();           			power=0;				}			 power = Math.floor(_progress*120);                if (power>=120) {                    power-=120;                }                my_canvas.graphics.clear();                my_canvas.graphics.lineStyle(10,0xffcb08,1);                draw_arc(my_canvas,-_size/10,_size/8,35,270,270+power*3,5);				my_canvas2.graphics.clear();                my_canvas2.graphics.lineStyle(5,0xf6c200,1)				draw_arc2(my_canvas2,-_size/10,_size/8,30,270,270+power*3,5);						}		override public function onProgress(progress:Number):void {			super.onProgress(progress);			draw();		}		public function draw_arc(movieclip,center_x,center_y,radius,angle_from,angle_to,precision) {            var angle_diff=angle_to-angle_from;            var steps=Math.round(angle_diff*precision);            var angle=angle_from;            var px=center_x+radius*Math.cos(angle*deg_to_rad);            var py=center_y+radius*Math.sin(angle*deg_to_rad);            movieclip.graphics.moveTo(px,py);            for (var i:int=1; i<=steps; i++) {                angle=angle_from+angle_diff/steps*i;                movieclip.graphics.lineTo(center_x+radius*Math.cos(angle*deg_to_rad),center_y+radius*Math.sin(angle*deg_to_rad));            }        }		public function draw_arc2(movieclip,center_x,center_y,radius,angle_from,angle_to,precision) {            var angle_diff=angle_to-angle_from;            var steps=Math.round(angle_diff*precision);            var angle=angle_from;            var px=center_x+radius*Math.cos(angle*deg_to_rad);            var py=center_y+radius*Math.sin(angle*deg_to_rad);            movieclip.graphics.moveTo(px,py);            for (var i:int=1; i<=steps; i++) {                angle=angle_from+angle_diff/steps*i;                movieclip.graphics.lineTo(center_x+radius*Math.cos(angle*deg_to_rad),center_y+radius*Math.sin(angle*deg_to_rad));            }        }        /*public function charge(e:MouseEvent) {            charging=true;        }        public function shoot(e:MouseEvent) {            charging=false;            my_canvas.graphics.clear();            power=0;        }        public function on_enter_frame(e:Event) {            if (charging) {                power++;                if (power>=120) {                    power-=120;                }                my_canvas.graphics.clear();                my_canvas.graphics.lineStyle(20,0x000000,1);                draw_arc(my_canvas,250,200,150,270,270+power*3,1);            }        }*/	}}